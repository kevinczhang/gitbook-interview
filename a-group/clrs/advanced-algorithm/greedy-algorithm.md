---
description: >-
  For many optimization problems, using dynamicprogramming to determine the best
  choices is overkill; simpler, more efficient algorithmswill do.
---

# Greedy Algorithm

A greedy algorithm always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice will lead to a globally optimal solution.

## Elements of the greedy strategy

A greedy algorithm obtains an optimal solution to a problem by making a sequence of choices.&#x20;

#### Greedy-choice property

The first key ingredient is the greedy-choice property: we can assemble a globally optimal solution by making locally optimal (greedy) choices.

A dynamic programming algorithm proceeds bottom up, whereas a greedy strategy usually progresses in a top-down fashion, making one greedy choice after another, reducing each given problem instance to a smaller one.

#### Optimal substructure

A problem exhibits optimal substructure if an optimal solution to the problem contains within it optimal solutions to subproblems. This property is a key ingredient of assessing the applicability of dynamic programming as well as greedy algorithms.

用数学归纳法证明

## An activity-selection problem

It also assumes that the input activities are ordered by monotonically increasing finish time.

### GREEDY-ACTIVITY-SELECTOR(s, f)

```bash
n = s:length
A = {a[1]}
k = 1
for m = 2 to n
    if s[m] >= f[k]
        A = A with {a[m]}
        k = m
return A
```

## Huffman codes

Huffman’s greedy algorithm uses a table giving how often each character occurs (i.e., its frequency) to build up an optimal way of representing each character as a binary string. Huffman invented a greedy algorithm that constructs an optimal prefix code called a **Huffman code**.

In the pseudocode that follows, we assume that **C** is a set of n characters and that each character $$c \in C$$is an object with an attribute _c.freq_ giving its frequency. The algorithm uses a min-priority queue Q, keyed on the _freq_ attribute, to identify the two least-frequent objects to merge together.

The code can convert string messages into least number of binary code based on frequency. The code and the tree can be transferred and the receiver can decode the message based on the code and tree.

```java
import java.util.PriorityQueue; 
import java.util.Scanner; 
import java.util.Comparator; 

// node class is the basic structure 
// of each node present in the Huffman - tree. 
class HuffmanNode { 

	int data; 
	char c; 

	HuffmanNode left; 
	HuffmanNode right; 
} 

// comparator class helps to compare the node 
// on the basis of one of its attribute. 
// Here we will be compared 
// on the basis of data values of the nodes. 
class MyComparator implements Comparator<HuffmanNode> { 
	public int compare(HuffmanNode x, HuffmanNode y) 
	{ 

		return x.data - y.data; 
	} 
} 

public class Huffman { 

	// recursive function to print the 
	// huffman-code through the tree traversal. 
	// Here s is the huffman - code generated. 
	public static void printCode(HuffmanNode root, String s) 
	{ 

		// base case; if the left and right are null 
		// then its a leaf node and we print 
		// the code s generated by traversing the tree. 
		if (root.left == null	&& root.right == null	&& Character.isLetter(root.c)) { 
			// c is the character in the node 
			System.out.println(root.c + ":" + s); 
			return; 
		} 

		// if we go to left then add "0" to the code. 
		// if we go to the right add"1" to the code. 

		// recursive calls for left and 
		// right sub-tree of the generated tree. 
		printCode(root.left, s + "0"); 
		printCode(root.right, s + "1"); 
	} 

	// main function 
	public static void main(String[] args) 
	{ 

		Scanner s = new Scanner(System.in); 

		// number of characters. 
		int n = 6; 
		char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' }; 
		int[] charfreq = { 5, 9, 12, 13, 16, 45 }; 

		// creating a priority queue q. 
		// makes a min-priority queue(min-heap). 
		PriorityQueue<HuffmanNode> q 
			= new PriorityQueue<HuffmanNode>(n, new MyComparator()); 

		for (int i = 0; i < n; i++) { 

			// creating a Huffman node object 
			// and add it to the priority queue. 
			HuffmanNode hn = new HuffmanNode(); 

			hn.c = charArray[i]; 
			hn.data = charfreq[i]; 

			hn.left = null; 
			hn.right = null; 

			// add functions adds 
			// the huffman node to the queue. 
			q.add(hn); 
		} 

		// create a root node 
		HuffmanNode root = null; 

		// Here we will extract the two minimum value 
		// from the heap each time until 
		// its size reduces to 1, extract until 
		// all the nodes are extracted. 
		while (q.size() > 1) { 

			// first min extract. 
			HuffmanNode x = q.peek(); 
			q.poll(); 

			// second min extarct. 
			HuffmanNode y = q.peek(); 
			q.poll(); 

			// new node f which is equal 
			HuffmanNode f = new HuffmanNode(); 

			// to the sum of the frequency of the two nodes 
			// assigning values to the f node. 
			f.data = x.data + y.data; 
			f.c = '-'; 

			// first extracted node as left child. 
			f.left = x; 

			// second extracted node as the right child. 
			f.right = y; 

			// marking the f node as the root node. 
			root = f; 

			// add this node to the priority-queue. 
			q.add(f); 
		} 

		// print the codes by traversing the tree 
		printCode(root, ""); 
	} 
} 

// This code is contributed by Kunwar Desh Deepak Singh 

```
